## 一、概述

程序编译成二进制本地机器码才能执行，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式

## 二、无关性

**平台无关性**

各种不同平台的**虚拟机**与所有平台都统一使用的程序存储格式**字节码**是构成平台无关性的基石。

**语言无关性**

虚拟机不与特定语言绑定，只与**class文件**这种特定的二进制文件格式所关联，class文件中包含了虚拟机指令集和符号表以及若干其他辅助信息

目前能在Java虚拟机上运行的语言有Clojure、Groovy、JRuby、Jython、Scala等

<!-- more -->

![](imgs\4-1.jpg)

字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大

## 三、Class类文件结构

Class文件是一组以**8位字节为基础单位**的二进制流，各个数据项目严格按照顺序紧凑地排列在class文件之中，没有空隙存在，也会进行分割存储，这也就解释前面提到**对象对齐填充**的原因

表是由多个无符号数（u1、u2、u4、u8）或者其他表作为数据项构成的复合数据类型，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式为某一类型的集合

![](imgs\4-2.png)

### 1、魔数与版本

**魔数**

身份识别：每个class文件的头4个字节称为魔数，作用是确定这个文件是否为一个能被虚拟机接受的class文件

**版本**

紧接着魔数的4个字节存储的是class文件的版本号，第5、6字节是次版本号，7、8字节是主版本号，虚拟机拒绝执行超过其版本号的class文件

| JDK版本 | 魔数 |
| ------- | ---- |
| 1.8     | 52   |
| 1.7     | 51   |
| 1.6     | 50   |

### 2、常量池

常量池可以理解为class文件之中的**资源仓库**，占用class文件空间最大的数据项目之一

入口放置一个u2类型的数据，代表常量池**容量计数**值，这个容量计数是从1开始的，将第0项常量空出来满足不引用任何一个常量池项目的情况

**存放内容**

**字面量**：文本字符串、声明为final的常量值

**符号引用**：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析、翻译到具体的内存地址之中，常量池中每一项常量都是一个表，表开始的第一位是一个u1类型的标志位（tag），代表当前属于常量类型

![](imgs\4-3.png)

![](imgs\4-4.png)

### 3、访问标志

常量池结束后，紧接着两个字节代表**访问标志**（access_flags），用于识别一些类或接口层次的访问信息

![](imgs\4-5.png)

access_flags中一共有16个标志位（2字节），当前只定义其中8个，没有使用到的标志位一律为0

参考Java**位掩码**的设计思想

### 4、类索引、父类索引、接口索引集合

类索引（父类索引）用一个u2类型的索引值表示，指向一个CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info常量中的索引值找到CONSTANT_Utf8_info中的全限定名字符串

​							**CONSTANT_Class_info型常量结构**

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

​							**CONSTANT_Utf8_info型常量结构**

| 类型 | 名称   | 数量   |
| ---- | ------ | ------ |
| u1   | tag    | 1      |
| u2   | length | 1      |
| u1   | bytes  | length |

对于接口索引集合，入口为一项u2类型数据-**接口计数器**，表示索引表的容量

### 5、字段表集合

字段表用于描述接口或者类中声明的变量。字段包括类级变量（static）、实例级变量，但不包括方法内声明的局部变量

| 类型           | 名称             | 数量             | 说明                                              |
| -------------- | ---------------- | ---------------- | ------------------------------------------------- |
| u2             | access_flags     | 1                | 修饰符                                            |
| u2             | name_index       | 1                | 代表字段的简单名称，占2字节，是一个对常量池的引用 |
| u2             | descriptor_index | 1                | 代表字段的描述符，占2个字节，是一个对常量池的引用 |
| u2             | attributes_count | 1                | 属性计数器                                        |
| attribute_info | attributes       | attributes_count | 属性表集合                                        |

### 6、方法表集合

方法表用于描述接口或者类中声明的方法

![](imgs\4-6.png)

方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合Code属性中

有可能出现编译器自动添加的方法，最典型的便是类构造器<clinit>方法和实例构造器<init>方法

### 7、属性表集合

在class文件、字段表、方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息

![](imgs\4-7.png)

**属性表结构：**

| 类型 | 名称                                       | 数量             |
| ---- | ------------------------------------------ | ---------------- |
| u2   | attribute_name_index（属性名称）           | 1                |
| u4   | attribute_length（属性值长度，不包含名称） | 1                |
| u1   | info                                       | attribute_length |

**1、Code属性**

**方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合Code属性中**

![](imgs\4-8.png)

Code属性是class文件中最重要的一个属性，一个Java程序中的信息分为**代码**（Code）和**元数据**（Metadata）两部分，Code属性用于描述方法体中代码，元数据用于描述所有其他数据项目（类、字段、方法）

**2、Exceptions属性**

列出方法中可能抛出的受查异常，也就是方法描述时throws关键字后面列举的异常

![](imgs\4-9.png)

**3、LineNumberTable属性**

用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系

不是必须的，主要影响就是当抛出异常时，堆栈中将不会显示出错的行号

![](imgs\4-10.png)

**4、LocalVariableTable属性**

用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系

不是必须的，最大的影响就是当引用某方法时，IDE将会使用arg0、arg1之类占位符代替原有参数名

对于非泛型来说，描述符和特征签名是基本一致的，泛型引入后（JDK1.5），由于描述符中泛型的参数化类型被擦除掉，描述符就不能准确的描述泛型类型了，因此出现了**LocalVariableTypeTable**

![](imgs\4-11.png)

![](imgs\4-12.png)

**5、SourceFile属性**

用于记录生成这个class文件的源码文件名称

不是必须的，如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名

![](imgs\4-13.png)

**6、ConstantValue属性**

作用是通知虚拟机自动为静态变量赋值，只有被使用static关键字修饰的变量才可以使用此属性

![](imgs\4-14.png)

| 赋值情况                         | 虚拟机操作                        |
| -------------------------------- | --------------------------------- |
| 非static类型变量                 | 实例构造器<init>方法进行          |
| final+static+基本类型/String     | 生成ConstantValue属性来进行初始化 |
| static，非final/基本类型、String | 类构造器<clinit>方法进行          |

**7、InnerClasses属性**

用于记录内部类与宿主类之间的关联

![](imgs\4-15.png)

![](imgs\4-16.png)

**8、Deprecated及Synthetic属性**

两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念

Deprecated属性用于表示某个类、字段、方法为不再推荐使用（过时/替换）

Synthetic属性用于表示字段、方法由编译器自行添加的（init、clinit特殊）

![](imgs\4-17.png)

**9、StackMapTable属性**

这个属性会在虚拟机类加载的字节码验证阶段被**类型检查验证器**使用，代替之前比较消耗性能的基于数据流分析的**类型推导验证器**

在编译阶段将一系列的验证类型直接记录在class文件之中，通过检查这些验证类型代替类型推导过程，大幅提升了字节码验证的性能，JDK1.7替换掉类型推导验证器

**10、Signature属性**

之所以要专门使用这样一个属性去记录泛型数据，是因为Java泛型采用的是擦除法实现的伪泛型，在字节码中，泛型信息编译之后都通通被擦除

现在Java的反射API能够获取泛型数据源于这个属性

**11、BootstrapMethods属性**

用于保存invokedynamic指令引用的引导方法限定符

## 四、字节码指令

### **0、简介**

字节码=操作码+操作数

Java虚拟机采用面向**操作数栈**而不是**寄存器**的架构，所以大多数的指令都不包含操作数，只有一个操作码

寄存器中读取指令，操作数栈执行操作

**执行模型：**

```java
do{
    自动计算PC寄存器的值加+1;
    根据PC寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数)	从字节码流中取出操作数;
    执行操作码所定义的操作;
}while(字节码流长度>0);
```

### 1、字节码与数据类型

| 字符 | 含义                    |
| ---- | ----------------------- |
| i    | int数据类型的操作       |
| l    | long数据类型的操作      |
| s    | short数据类型的操作     |
| b    | byte数据类型的操作      |
| c    | char数据类型的操作      |
| f    | float数据类型的操作     |
| d    | double数据类型的操作    |
| a    | reference数据类型的操作 |

有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型（arraylength、goto）

大多数的boolean、byte、short、char类型数据的操作，实际上都是使用相应的int类型作为运算类型

### 2、加载和存储指令

用于将数据在栈帧中的**局部变量表**和**操作数栈**之间来回传输

加载：局部变量表-操作数栈

存储：操作数栈-局部变量表

### 3、运算指令

用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作数栈顶

### 4、类型转换指令

将两种不同的数值类型进行相互转换

### 5、对象创建与访问指令

创建类实例的指令：new

创建数组的指令：newarray

访问类字段：getfield、putfield、getstatic、putstatic

取数组长度：arraylength

检查类实例类型：instanceof

### 6、操作数栈管理指令

直接操作操作数栈的指令

操作数栈栈顶出栈：pop

复制栈顶并重新压入栈顶：dup

栈最顶端两个数值互换：swap

### 7、控制转移指令

有条件或无条件的修改PC寄存器的值（循环、跳转）

条件分支：ifeq

复合条件分支：tableswitch

无条件分支：goto

各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的

### 8、方法调用和返回指令

invokevirtual：调用对象的实例方法

invokeinterface：调用接口方法

invokespecial：调用需要特殊处理的实例方法（实例初始化方法、私有方法、父类方法）

invokestatic：调用类方法（static方法）

invokedynamic：执行运行时动态解析出调用点限定符所引用的方法

方法调用指令与数据类型无关，但方法返回指令是根据返回值类型区分的，如ireturn，还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用

### 9、异常处理指令

Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，采用异常表完成

### 10、同步指令

同步一段指令集序列通常是由Java语言中的**synchronized**语句块来表示的，Java虚拟机的指令集中有**monitorenter**和**monitorexit**两条指令来支持synchronized关键字的语义

## 五、公有设计和私有实现

公有设计：class文件格式、字节码指令集

私有实现：class文件的处理（同步、异常不同实现）

**虚拟机实现方式：**

将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集

将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（JIT代码生成技术）

## 六、Class文件结构的发展

目前，所有对Class文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容

## 扩展阅读

- [字节码指令大全](https://www.cnblogs.com/longjee/p/8675771.html)
- [JIT编译器理解](https://www.cnblogs.com/insistence/p/5901457.html)
- [机器码与字节码](https://www.cnblogs.com/qiumingcheng/p/5400265.html)

